# Tutorial: TimeTableMaker-BITS

This project is a **Course Evaluation System** that helps a university manage its academic activities. It allows different *users* (like students, instructors, and administrators) to interact with the system. Students can view available *courses*, *enroll* in them, and see their *timetable*. Instructors can view their assigned courses and enrolled students. Administrators can manage *users*, *courses*, and generate overall *timetables*. All the information about users, courses, and enrollments is stored persistently using *database helper classes*, and users interact with the system through various *graphical user interface (GUI) pages*.


## Visual Overview

```mermaid
flowchart TD
    A0["User (and roles)
"]
    A1["Course
"]
    A2["TimeSlot
"]
    A3["Timetable
"]
    A4["Enrollment
"]
    A5["Database Classes (UserDatabase, CourseDatabase, EnrollmentDatabase)
"]
    A6["GUI Pages (LoginPage, Home screens)
"]
    A0 -- "Stored in" --> A5
    A0 -- "Uses GUI" --> A6
    A1 -- "Stored in" --> A5
    A1 -- "Scheduled as" --> A2
    A2 -- "Part of" --> A3
    A3 -- "Displayed by GUI" --> A6
    A4 -- "Stored in" --> A5
    A4 -- "Links Student" --> A0
    A4 -- "Links Course" --> A1
    A5 -- "Used by GUI" --> A6
    A6 -- "Manages Users" --> A0
    A6 -- "Manages/Displays Courses" --> A1
    A6 -- "Manages Enrollments" --> A4
```

## Chapters

1. [GUI Pages (LoginPage, Home screens)
](01_gui_pages__loginpage__home_screens__.md)
2. [User (and roles)
](02_user__and_roles__.md)
3. [Course
](03_course_.md)
4. [Enrollment
](04_enrollment_.md)
5. [TimeSlot
](05_timeslot_.md)
6. [Timetable
](06_timetable_.md)
7. [Database Classes (UserDatabase, CourseDatabase, EnrollmentDatabase)
](07_database_classes__userdatabase__coursedatabase__enrollmentdatabase__.md)

---

<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub>



# Chapter 1: GUI Pages (LoginPage, Home screens)

Welcome to the tutorial for the `TimeTableMaker-BITS` project! This project helps manage course schedules and enrollments.

In any software you use, you interact with buttons, text fields, windows, and menus. These are all parts of the **Graphical User Interface (GUI)**. Think of the GUI as the "face" of the software â€“ what you see and click on.

In our `TimeTableMaker-BITS` system, the GUI is made up of different **pages** or **windows**. Each page serves a specific purpose and looks different depending on what you need to do.

## The Starting Point: The Login Page

Before anyone can use the system, they need to identify themselves. Are you a student? An instructor? An administrator? The system needs to know who you are to show you the right information and allow you to perform the correct actions.

This is where the **`LoginPage`** comes in. It's the very first window you see when you start the application. It's like the front door of the system.

On the `LoginPage`, you typically:
1.  Select your role (Student, Instructor, or Admin).
2.  Enter your username.
3.  Enter your password.
4.  Click a "Login" button.

If the information you enter is correct and matches a user in the system with that specific role, you are allowed in!

## Your Command Center: The Home Screens

Once you successfully log in, the `LoginPage` disappears, and you are taken to a **Home Screen**. But not just *any* home screen! The system shows you a dashboard tailored specifically for your role.

*   **`StudentHome`**: If you logged in as a Student, you'll see the `StudentHome` page. This page shows you the courses you are currently enrolled in, available courses you can add, and options to view your schedule or add/drop courses. It's your personal academic dashboard.
*   **`InstructorHome`**: If you are an Instructor, you get the `InstructorHome`. This page will show you the courses you are assigned to teach and might let you view the students in your courses or manage your teaching schedule.
*   **`AdminHome`**: The Admin has the most control and sees the `AdminHome`. This page allows administrators to manage users (add, edit, delete), manage courses, and even generate system-wide timetables.

These home screens are where you'll spend most of your time interacting with the system after logging in.

## How the Application Starts

Let's look at the very first piece of code that runs when the application starts.

```java
// --- File: src/main/java/com/courseevaluation/main/CourseEvaluationSystem.java ---
package com.courseevaluation.main;

import com.courseevaluation.data.*;
import com.courseevaluation.gui.LoginPage; // Import the LoginPage class
import javax.swing.SwingUtilities;

public class CourseEvaluationSystem {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            // ... (Database setup - covered in later chapters) ...

            // Create and show the LoginPage
            LoginPage loginPage = new LoginPage(userDatabase, courseDatabase, enrollmentDatabase);
            loginPage.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);
            loginPage.setSize(600, 400); // Set the window size
            loginPage.setLocationRelativeTo(null); // Center the window
            loginPage.setVisible(true); // Make the window visible
        });
    }
}
```

This code is the *entry point* of our program. It does some initial setup (like getting ready to handle data, which we'll see in future chapters), and then its main job is to create an instance of `LoginPage` and make it appear on your screen using `loginPage.setVisible(true)`.

This confirms that `LoginPage` is indeed the first GUI page the user sees.

## How Login Works (Simplified)

When you enter your details on the `LoginPage` and click the button, what happens behind the scenes?

1.  The `LoginPage` takes the username, password, and selected role from the fields you filled.
2.  It asks the system's data manager (we'll cover this in [Chapter 7: Database Classes](07_database_classes__userdatabase__coursedatabase__enrollmentdatabase__.md)) if a user with that username exists and if the password is correct.
3.  It also checks if the user's actual role matches the role you selected on the page.
4.  If everything matches, the `LoginPage` then decides which **Home Screen** to create (`StudentHome`, `InstructorHome`, or `AdminHome`) based on the validated user's role.
5.  The `LoginPage` window is then hidden or closed, and the correct Home Screen window appears.
6.  If the credentials or role don't match, the `LoginPage` shows an error message, and you stay on the login page.

Here's a simple diagram showing the successful login flow:

```mermaid
sequenceDiagram
    actor User
    participant LP as Login Page
    participant UD as UserDatabase
    participant HS as Home Screen

    User->>LP: Enter username, password, role and click Login
    LP->>UD: Ask to validate credentials and role
    UD-->>LP: Return validation result (e.g., valid Student user object)
    Note over LP: If valid and role matches...
    LP->>HS: Create appropriate Home Screen (e.g., StudentHome)
    LP->>LP: Hide or close Login Page
    HS-->>User: Display tailored Home Screen
```

## Showing the Right Home Screen in Code

Let's look at a snippet from the `LoginPage` code that handles what happens after a successful login.

```java
// --- File: src/main/java/com/courseevaluation/gui/LoginPage.java ---
// ... imports and class definition ...

private void handleLogin() {
    String username = usernameField.getText();
    String password = new String(passwordField.getPassword());
    String selectedRole = (String) roleComboBox.getSelectedItem();

    User user = userDatabase.findUser(username); // Find user in the database
    if (user != null && user.getPassword().equals(password)) { // Check password
        // Check if the user's role matches the selected role
        boolean roleMatches = false;
        if (selectedRole.equals("Student") && user instanceof Student) {
            roleMatches = true;
        } else if (selectedRole.equals("Instructor") && user instanceof Instructor) {
            roleMatches = true;
        } else if (selectedRole.equals("Admin") && user instanceof Admin) {
            roleMatches = true;
        }

        if (roleMatches) {
            this.dispose(); // Close the Login page
            if (user instanceof Student) {
                // Create and show StudentHome
                new StudentHome((Student) user, courseDatabase, enrollmentDatabase, userDatabase);
            } else if (user instanceof Instructor) {
                // Create and show InstructorHome
                new InstructorHome(userDatabase, courseDatabase, enrollmentDatabase, (Instructor) user);
            } else if (user instanceof Admin) {
                // Create and show AdminHome
                new AdminHome(userDatabase, courseDatabase, enrollmentDatabase);
            }
        } else {
            // ... (Show "Invalid role" message) ...
        }
    } else {
        // ... (Show "Invalid username or password" message) ...
    }
}
```

This `handleLogin` method contains the core logic. It retrieves user input, checks against the `userDatabase`, and if validation succeeds, it creates an instance of the correct Home screen class (`StudentHome`, `InstructorHome`, or `AdminHome`) and makes it visible. The `this.dispose()` line closes the `LoginPage` window.

## Inside a Home Screen (Student Home Example)

Now let's peek into one of the Home screen classes, like `StudentHome`, to see how it gets set up.

```java
// --- File: src/main/java/com/courseevaluation/gui/StudentHome.java ---
package com.courseevaluation.gui;

import com.courseevaluation.data.UserDatabase;
// ... other imports ...
import com.courseevaluation.models.Student; // Import Student model
import javax.swing.*; // GUI components

public class StudentHome extends JFrame { // StudentHome is a window (JFrame)
    private final Student student; // The logged-in student object
    // ... references to databases ...
    
    // ... UI components like tables, buttons ...

    public StudentHome(Student student, CourseDatabase courseDatabase, EnrollmentDatabase enrollmentDatabase, UserDatabase userDatabase) {
        this.student = student; // Store the student object
        this.courseDatabase = courseDatabase;
        this.enrollmentDatabase = enrollmentDatabase;
        this.userDatabase = userDatabase;
        // ... initialize lists/panels ...

        initializeUI(); // Set up the window properties and contents
        loadEnrolledCourses(); // Load data specific to this student
    }

    private void initializeUI() {
        setTitle("Student Dashboard - " + student.getUsername()); // Set window title
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // Exit when window closed
        setSize(900, 700); // Set window size
        setLocationRelativeTo(null); // Center window

        initializeComponents(); // Add buttons, tables, etc.
        setVisible(true); // Make the window visible
    }

    // ... other methods like initializeComponents(), loadEnrolledCourses(), showAddCourseDialog(), handleLogout(), etc. ...
}
```

The `StudentHome` class is a type of `JFrame`, which means it's a top-level window. Its constructor takes the `Student` object (passed from the `LoginPage`) and the necessary database objects. It then calls helper methods like `initializeUI()` and `initializeComponents()` to set up the visual elements you see on the screen (tables, buttons, labels) and `loadEnrolledCourses()` to fetch data specific to the logged-in student and display it.

Each Home screen (`StudentHome`, `InstructorHome`, `AdminHome`) will have its own specific set of components and data loading logic relevant to that role.

One common feature they share is the ability to **logout**. This usually involves closing the current Home screen window and showing the `LoginPage` again, ready for the next user.

```java
// --- File: src/main/java/com/courseevaluation/gui/StudentHome.java ---
// ... other methods ...

private void handleLogout() {
    int choice = JOptionPane.showConfirmDialog(
        this, // The current window (StudentHome)
        "Are you sure you want to logout?",
        "Logout Confirmation",
        JOptionPane.YES_NO_OPTION
    );

    if (choice == JOptionPane.YES_OPTION) {
        dispose(); // Close the current Home screen window
        // Create a new LoginPage and show it
        new LoginPage(userDatabase, courseDatabase, enrollmentDatabase).setVisible(true);
    }
}
```

This `handleLogout` method demonstrates the typical flow: ask the user for confirmation, close the current window (`dispose()`), and create and show a new `LoginPage`.

## Conclusion

In this chapter, we learned that the user interface of the `TimeTableMaker-BITS` system is built using different visual windows called **GUI Pages**. The **`LoginPage`** is the essential first step to identify yourself, and based on your role (Student, Instructor, or Admin), you are directed to a tailored **Home Screen** (`StudentHome`, `InstructorHome`, or `AdminHome`) which serves as your main dashboard. We saw how the application starts by showing the `LoginPage` and how a successful login leads to the appropriate Home screen being displayed.

Now that we understand the different entry points and dashboards based on who the user is, the next logical step is to understand what a "User" is in more detail and the different "Roles" they can have in the system.

[Next Chapter: User (and roles)](02_user__and_roles__.md)

---

<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/gui/AdminHome.java), [[2]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/gui/InstructorHome.java), [[3]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/gui/LoginPage.java), [[4]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/gui/StudentHome.java), [[5]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/main/CourseEvaluationSystem.java)</sup></sub>



# Chapter 2: User (and roles)

Welcome back! In [Chapter 1: GUI Pages (LoginPage, Home screens)](01_gui_pages__loginpage__home_screens__.md), we saw how the system greets you with a `LoginPage` and then directs you to a specific `Home Screen` (`StudentHome`, `InstructorHome`, or `AdminHome`) depending on who you are.

But how does the system know who you are? And how does it know what kind of `Home Screen` you should see?

This is where the concept of a **User** comes in!

## What is a User?

Think of a `User` as an identity card for anyone interacting with our `TimeTableMaker-BITS` system. Just like your ID card has your name, a unique number, and maybe your photo, a `User` object in our system stores basic, common information about a person.

What kind of information? Things like:

*   **Username:** A unique name used to log in (e.g., `student1`, `instructor2`, `admin1`).
*   **Password:** The secret code used for verification.
*   **Name:** The person's full name (e.g., "John Doe").
*   **Department:** Which department they belong to.

Having a `User` concept is crucial because *everyone* who uses the system â€“ whether they are a student, an instructor, or an admin â€“ needs this basic identity information.

## Why "and roles"?

Not everyone using the system has the same needs or permissions. A student needs to enroll in courses, an instructor needs to manage their classes, and an administrator needs to manage everything!

This is where **Roles** come in. A role defines *what a user is allowed to do* and *what information they see*. In our system, the main roles are:

*   **Student:** Can view their timetable, enroll/drop courses, etc.
*   **Instructor:** Can view their teaching schedule, perhaps see their enrolled students (depending on full implementation).
*   **Admin:** Has full control â€“ can add/remove users, create courses, manage the entire system.

You can think of the `User` as the common identity card, and the `Role` as a set of different keys this identity card holds. A `Student` key unlocks student features, an `Instructor` key unlocks instructor features, and an `Admin` key unlocks administrative features.

## How Users and Roles are Represented in Code

In programming, we often represent these concepts using classes.

### The Base User Class

We have a main `User` class that holds the common information shared by everyone.

```java
// --- File: src/main/java/com/courseevaluation/models/User.java ---
package com.courseevaluation.models;

public abstract class User { // 'abstract' means it's a blueprint, you can't create a plain User, only specific roles
    private String username;
    private String password;
    private String role; // Stores the role (e.g., "STUDENT", "INSTRUCTOR", "ADMIN")
    private String name;
    private String department;
    // ... other common details or methods ...

    public User(String username, String password, String role, String name, String department) {
        this.username = username;
        this.password = password;
        this.role = role; // Set the role when creating the user
        this.name = name;
        this.department = department;
        // ... initialize other fields ...
    }

    // Getters for username, password, role, name, department etc.
    public String getUsername() { return username; }
    public String getPassword() { return password; }
    public String getRole() { return role; }
    // ... other getters ...

    // ... setters or other common methods ...
}
```

This `User` class acts like a blueprint for anyone who will use the system. It includes fields that *all* users have. Notice the `role` field explicitly stores the role as a piece of data.

### The Specific Role Classes

Then, we have separate classes for each specific role: `Student`, `Instructor`, and `Admin`. These classes **extend** the `User` class. This means they *inherit* all the common information and abilities from `User` but can also add their own unique details.

Think of it like this: A "Student ID" (Student class) is a type of "Identity Card" (User class). It has all the ID card features PLUS extra student-specific info like student ID number, major, and year.

Here's a simplified look at the `Student` class:

```java
// --- File: src/main/java/com/courseevaluation/models/Student.java ---
package com.courseevaluation.models;

// 'extends User' means Student is a type of User and gets all its fields/methods
public class Student extends User {
    private String studentId; // Unique to Student
    private String major;     // Unique to Student
    private int year;         // Unique to Student
    // ... other student-specific details like enrolled courses ...

    public Student(String username, String password, String name, String department,
                  String studentId, String major, int year) {
        // Call the parent User constructor to set common details
        super(username, password, "STUDENT", name, department);
        // Set the student-specific details
        this.studentId = studentId;
        this.major = major;
        this.year = year;
        // ... initialize enrolled courses list ...
    }

    // Getters for student-specific fields
    public String getStudentId() { return studentId; }
    public String getMajor() { return major; }
    // ... other student-specific getters/methods ...

    // ... methods like enrollInCourse(), dropCourse() ...
}
```

Notice how the `Student` constructor calls `super(...)`. This passes the common information (username, password, name, department) to the `User` class's constructor to set those fields. It also explicitly sets the `role` to `"STUDENT"` within the `super` call.

Similarly, `Instructor` and `Admin` classes extend `User` and add their own unique fields (like `instructorId`, `specialization` for Instructor, or `adminId`, `accessLevel` for Admin).

```java
// Instructor class (simplified)
public class Instructor extends User {
    private String instructorId;
    private String specialization;
    // ... teaching courses list ...

    public Instructor(String username, String password, String name, String department, String instructorId, String specialization) {
        super(username, password, "INSTRUCTOR", name, department); // Sets role to "INSTRUCTOR"
        this.instructorId = instructorId;
        this.specialization = specialization;
        // ... initialize teaching courses list ...
    }
    // ... getters and methods ...
}
```

```java
// Admin class (simplified)
public class Admin extends User {
    private String adminId;
    private String accessLevel;

    public Admin(String username, String password, String name, String department, String adminId, String accessLevel) {
        super(username, password, "ADMIN", name, department); // Sets role to "ADMIN"
        this.adminId = adminId;
        this.accessLevel = accessLevel;
    }
    // ... getters and methods ...
}
```

This setup means:
*   Any object that is a `Student` is also a `User`.
*   Any object that is an `Instructor` is also a `User`.
*   Any object that is an `Admin` is also a `User`.

This hierarchical structure helps organize the code and data.

## How the LoginPage Uses Users and Roles

Remember in [Chapter 1](01_gui_pages__loginpage__home_screens__.md) we saw the login logic? Now we can understand it better.

When you enter your username, password, and select a role on the `LoginPage`:

1.  The system looks up the user based on the `username` you provided. It gets back a `User` object (which could actually be a `Student`, `Instructor`, or `Admin` object).
2.  It checks if the provided `password` matches the password stored in that `User` object.
3.  Crucially, it then checks if the *actual type* of the `User` object matches the `role` you selected on the screen.

Here's that snippet again, with comments highlighting the role check:

```java
// --- File: src/main/java/com/courseevaluation/gui/LoginPage.java ---
// ... inside handleLogin() method ...

private void handleLogin() {
    String username = usernameField.getText();
    String password = new String(passwordField.getPassword());
    String selectedRole = (String) roleComboBox.getSelectedItem(); // Role chosen from dropdown

    User user = userDatabase.findUser(username); // Get the User object from database
    if (user != null && user.getPassword().equals(password)) { // Check password
        // Now, check if the actual type of the 'user' object matches the 'selectedRole'
        boolean roleMatches = false;
        if (selectedRole.equals("Student") && user instanceof Student) { // Is it a Student object?
            roleMatches = true;
        } else if (selectedRole.equals("Instructor") && user instanceof Instructor) { // Is it an Instructor object?
            roleMatches = true;
        } else if (selectedRole.equals("Admin") && user instanceof Admin) { // Is it an Admin object?
            roleMatches = true;
        }

        if (roleMatches) {
            this.dispose(); // Close Login page
            // Create the Home Screen based on the *actual type* of the user object
            if (user instanceof Student) {
                new StudentHome((Student) user, /*...*/); // Pass the specific Student object
            } else if (user instanceof Instructor) {
                new InstructorHome(/*...*/, (Instructor) user); // Pass the specific Instructor object
            } else if (user instanceof Admin) {
                new AdminHome(/*...*/); // AdminHome might not need the specific Admin object instance
            }
        } else {
            // Show "Invalid role selected for this user" message
        }
    } else {
        // Show "Invalid username or password" message
    }
}
```

The `instanceof` keyword is how Java checks the *type* of an object. This logic ensures that even if a username/password is correct, you can only log in as a "Student" if the user account is actually a `Student` type.

## Where are Users Stored?

Our system needs to remember all the users. This data is stored externally (so it persists even if the program closes) and managed by a special class. We'll cover data management in detail in [Chapter 7: Database Classes](07_database_classes__userdatabase__coursedatabase__enrollmentdatabase__.md), but for now, let's look at how the `User` data is loaded.

The user data is stored in a simple text file called `users.csv`. Each line in the file represents a user, and the information is separated by commas (CSV stands for Comma Separated Values). The first piece of data on each line tells us the role!

Example from `data/users.csv`:

```csv
STUDENT,student1,password123,John Doe,Computer Science,2022AAPS1234H,Computer Science,2
INSTRUCTOR,instructor1,password456,Dr. Smith,Computer Science,INS001,Data Structures
ADMIN,admin1,admin123,Admin User,Administration,ADM001,SUPER
```

### Loading Users from the File

The `UserDatabase` class is responsible for reading this file when the application starts and creating the correct `User` objects (either `Student`, `Instructor`, or `Admin`) in memory.

```java
// --- File: src/main/java/com/courseevaluation/data/UserDatabase.java ---
package com.courseevaluation.data;

import com.courseevaluation.models.User;
import com.courseevaluation.models.Student; // Import Student class
import com.courseevaluation.models.Instructor; // Import Instructor class
import com.courseevaluation.models.Admin; // Import Admin class
import java.io.*;
import java.util.ArrayList;
import java.util.List;

public class UserDatabase {
    private static final String USER_FILE = "data/users.csv";
    private List<User> users; // Stores all user objects (could be Student, Instructor, or Admin)

    public UserDatabase() {
        users = new ArrayList<>();
        loadUsers(); // Load users when UserDatabase is created
    }

    private void loadUsers() {
        try (BufferedReader reader = new BufferedReader(new FileReader(USER_FILE))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split(","); // Split the line by comma
                String roleType = parts[0]; // Get the first part (e.g., "STUDENT")

                // Based on the role type, create the correct object
                if (roleType.equals("STUDENT")) {
                    // Create a new Student object using parts from the file
                    users.add(new Student(parts[1], parts[2], parts[3], parts[4], parts[5], parts[6], Integer.parseInt(parts[7])));
                } else if (roleType.equals("INSTRUCTOR")) {
                    // Create a new Instructor object
                    users.add(new Instructor(parts[1], parts[2], parts[3], parts[4], parts[5], parts[6]));
                } else if (roleType.equals("ADMIN")) {
                    // Create a new Admin object
                    users.add(new Admin(parts[1], parts[2], parts[3], parts[4], parts[5], parts[6]));
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading users: " + e.getMessage());
        }
    }

    // ... findUser() method used by LoginPage ...
    public User findUser(String username) {
        for (User user : users) { // Iterate through the list of User objects
            if (user.getUsername().equals(username)) {
                return user; // Return the found User object (which is actually Student/Instructor/Admin)
            }
        }
        return null; // User not found
    }
    // ... other methods like addUser(), saveUsers() ...
}
```

This code shows how the `UserDatabase` reads each line, looks at the first part (the role), and then uses the correct constructor (`new Student(...)`, `new Instructor(...)`, `new Admin(...)`) to create the right type of object before adding it to a list of `User` objects. When `findUser` is called, it returns the object it found, which is still its specific type (Student, Instructor, or Admin), allowing the `LoginPage` to check its exact role using `instanceof`.

## User Roles Summary

Here's a quick comparison of the different roles and what they generally do in the system:

| Role        | Key Unique Info        | Main Capabilities (High-Level)                       | Home Screen      |
| :---------- | :--------------------- | :--------------------------------------------------- | :--------------- |
| **Student** | Student ID, Major, Year | View schedule, Enroll/drop courses, View course info | `StudentHome`    |
| **Instructor**| Instructor ID, Specialization | View teaching schedule, View student lists (potentially) | `InstructorHome` |
| **Admin**   | Admin ID, Access Level | Manage users, Manage courses, Generate timetables    | `AdminHome`      |

## The Journey of a User Object (Simplified Login)

Let's visualize the path a user's identity takes during a successful login using our `User` and `Role` concepts.

```mermaid
sequenceDiagram
    actor UserInput as User Input (LoginPage)
    participant LP as LoginPage
    participant UD as UserDatabase
    participant UserObj as User Object (in memory)
    participant HS as Home Screen

    UserInput->>LP: Username, Password, Selected Role
    LP->>UD: findUser(username)
    UD-->>LP: Return UserObj (e.g., a Student object)
    Note over LP: Check password and check<br/>UserObj type matches Selected Role<br/>(e.g., is UserObj instanceof Student?)
    alt Role and Password Match
        LP->>LP: Hide/Close LoginPage
        LP->>HS: Create correct Home Screen<br/>(e.g., new StudentHome(UserObj, ...))
        HS-->>UserInput: Display Home Screen for role
    else Role or Password Mismatch
        LP->>UserInput: Show Error Message
    end
```

This diagram shows that the `LoginPage` interacts with the `UserDatabase` to retrieve a generic `User` object, but it then uses the specific type of that object (which holds the role information internally, both via the `role` field and its class type) to determine the next step and create the correct `Home Screen`.

## Conclusion

In this chapter, we explored the fundamental concept of a **User** in the `TimeTableMaker-BITS` system. We learned that a `User` represents an individual's identity with common details like username and password. Crucially, we understood that users have different **Roles** (`Student`, `Instructor`, `Admin`), which determine their abilities and the parts of the system they can access. We saw how these roles are represented by specific classes that extend the base `User` class and how the system, particularly the `LoginPage`, uses the user's role to direct them to the appropriate `Home Screen`. We also got a glimpse into how `User` data is loaded and managed by the `UserDatabase`.

Now that we understand who the users are and what roles they play, the next important concept is the building block of any academic system: the **Course**.

[Next Chapter: Course](03_course_.md)

---

<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/data/users.csv), [[2]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/data/UserDatabase.java), [[3]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/models/Admin.java), [[4]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/models/Instructor.java), [[5]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/models/Student.java), [[6]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/models/User.java)</sup></sub>



# Chapter 3: Course

Welcome back! In our previous chapter, [Chapter 2: User (and roles)](02_user__and_roles__.md), we learned about the different people who use the `TimeTableMaker-BITS` system â€“ Students, Instructors, and Admins â€“ and how their roles determine what they can do.

Now, what do these users actually *do* in an academic system? They interact with things like subjects, classes, or lectures. In the world of university scheduling, these are called **Courses**.

Imagine you're a student wanting to pick classes for the next semester. You need to see a list of available subjects, their names, who teaches them, when they meet, and if there's still space. Or maybe you're an administrator setting up the schedule, and you need to define these subjects in the system. This is exactly where the concept of a **Course** comes in!

## What is a Course?

At its heart, a **Course** in our system is like an entry in a university's course catalog. It describes a single subject or class that is being offered. It holds all the important information someone needs to know about that specific offering.

Think of it like an item in a shop's inventory. Each item has a unique code, a name, a price (credits), maybe a picture (instructor), and details about its availability (schedule, capacity).

In `TimeTableMaker-BITS`, a `Course` object bundles together these key pieces of information:

*   **Course Code:** A unique identifier (like CS101, EE202).
*   **Title:** The full name of the course (like "Introduction to Programming").
*   **Instructor:** Who is teaching the course (we'll link this to the `Instructor` user later!).
*   **Credits:** How many credits the course is worth.
*   **Schedule:** When and where the class meets (like "Mon 09:00-10:30"). This is a crucial detail for timetables!
*   **Max Students (Capacity):** The maximum number of students allowed in the course.
*   **Enrolled Students:** How many students are *currently* signed up.
*   **Status:** Whether the course is "OPEN" (has space) or "FULL" (no more space).

These details are all stored together within a single `Course` object.

## The Course Object in Code

Just like `User` is represented by a class in Java, the `Course` is also represented by a class. Let's look at a simplified version of the `Course.java` file.

```java
// --- File: src/main/java/com/courseevaluation/models/Course.java ---
package com.courseevaluation.models;

public class Course {
    private String courseCode; // Unique identifier
    private String title;      // Full name
    private String instructor; // Who teaches it
    private int credits;       // How many credits
    private String schedule;   // When and where
    private int enrolledStudents; // Current students
    private int maxStudents;    // Max students allowed
    private String status;      // "OPEN" or "FULL"

    // This is what creates a new Course object
    public Course(String courseCode, String title, String instructor, int credits,
                 String schedule, int maxStudents) {
        this.courseCode = courseCode;
        this.title = title;
        this.instructor = instructor;
        this.credits = credits;
        this.schedule = schedule;
        this.maxStudents = maxStudents;

        // When a course is first created, no one is enrolled
        this.enrolledStudents = 0;
        // And its status is initially OPEN
        this.status = "OPEN";
    }

    // Methods to get information from the Course object (getters)
    public String getCourseCode() { return courseCode; }
    public String getTitle() { return title; }
    // ... other getters for instructor, credits, schedule, maxStudents ...

    // Method to get and set the number of enrolled students
    public int getEnrolledStudents() { return enrolledStudents; }
    public void setEnrolledStudents(int enrolledStudents) {
        this.enrolledStudents = enrolledStudents;
        // Automatically update status based on enrollment
        if (this.enrolledStudents >= this.maxStudents) {
            this.status = "FULL";
        } else {
            this.status = "OPEN";
        }
    }

    public String getStatus() { return status; }

    // A helper method to check if the course is full
    public boolean isFull() {
        return enrolledStudents >= maxStudents;
    }

    // How the course looks when printed (optional, but helpful)
    @Override
    public String toString() {
        return String.format("%s - %s (%d/%d)", courseCode, title, enrolledStudents, maxStudents);
    }
}
```

This code shows the blueprint for a `Course`. When we create a `new Course(...)`, we provide the initial details, and it automatically sets the enrollment to zero and the status to "OPEN". It also includes "getter" methods (`getCourseCode()`, `getTitle()`, etc.) so other parts of the program can read its information. The `setEnrolledStudents()` method is special because it also automatically updates the `status`.

## How are Course Objects Used?

Course objects are central to many actions in the system:

*   **Viewing Course Lists:** When a student logs in, the `StudentHome` page needs to show a list of available courses. It gets `Course` objects and displays their details (code, title, instructor, schedule, enrollment/capacity).
*   **Checking Availability:** Before a student can enroll, the system checks the `Course` object's `isFull()` method or `getStatus()` to see if there's space.
*   **Building Timetables:** The `schedule` property of a `Course` is essential for creating a student's personal timetable or the system's overall timetable.
*   **Admin Management:** Admins create new `Course` objects or modify details of existing ones (like changing the instructor or increasing capacity).

Let's imagine the `StudentHome` page needs to show a list of courses. It would get a list of `Course` objects and loop through them to display information for each one:

```java
// --- Example snippet (simplified) ---
// Imagine this is part of StudentHome's display logic

CourseDatabase courseDatabase = new CourseDatabase(); // Get the database holding courses
List<Course> allCourses = courseDatabase.getAllCourses(); // Get a list of Course objects

System.out.println("Available Courses:");
for (Course course : allCourses) {
    // Use the getter methods to display details from each Course object
    System.out.printf("Code: %s, Title: %s, Instructor: %s, Schedule: %s, Status: %s%n",
        course.getCourseCode(),
        course.getTitle(),
        course.getInstructor(),
        course.getSchedule(),
        course.getStatus());
}

// --- Example Output (depends on data) ---
// Available Courses:
// Code: CS101, Title: Introduction to Programming, Instructor: instructor1, Schedule: Mon 09:00-10:30, Status: OPEN
// Code: CS102, Title: Data Structures and Algorithms, Instructor: instructor1, Schedule: Wed 10:30-12:00, Status: OPEN
// ... and so on for other courses ...
```

This simple loop shows how the `StudentHome` page gets `Course` objects from the database and uses their getter methods to extract and display the information needed by the student.

## Where are Courses Stored?

Just like user data, the system needs to remember all the courses even after it's closed. Course data is stored in a file named `data/courses.csv`. Each line describes one course, with details separated by commas.

Example from `data/courses.csv`:

```csv
CS101,Introduction to Programming,3,instructor1,Mon 09:00-10:30,0,40
CS102,Data Structures and Algorithms,4,instructor1,Wed 10:30-12:00,0,35
... (more courses) ...
```
Looking at the first line:
*   `CS101`: courseCode
*   `Introduction to Programming`: title
*   `3`: credits
*   `instructor1`: instructor (this is likely the username or ID of an Instructor User!)
*   `Mon 09:00-10:30`: schedule
*   `0`: enrolledStudents (initially 0)
*   `40`: maxStudents

## Loading and Managing Courses with CourseDatabase

The `CourseDatabase` class is responsible for reading the `courses.csv` file, creating `Course` objects in memory when the application starts, and providing methods for other parts of the system to find or list courses.

Let's look at the `loadCourses` method in `CourseDatabase.java`:

```java
// --- File: src/main/java/com/courseevaluation/data/CourseDatabase.java ---
package com.courseevaluation.data;

import com.courseevaluation.models.Course; // Need the Course class
import java.io.*;
import java.util.ArrayList;
import java.util.List;

public class CourseDatabase {
    private static final String COURSE_FILE = "data/courses.csv";
    private List<Course> courses; // A list to hold all the Course objects

    public CourseDatabase() {
        courses = new ArrayList<>();
        loadCourses(); // Load data when the database object is created
    }

    private void loadCourses() {
        try (BufferedReader reader = new BufferedReader(new FileReader(COURSE_FILE))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split(","); // Split the line by commas

                // Create a new Course object using the parts from the file
                Course course = new Course(
                    parts[0],  // courseCode
                    parts[1],  // title
                    Integer.parseInt(parts[2]),  // credits (convert text to number)
                    parts[3],  // instructor
                    parts[4],  // schedule
                    Integer.parseInt(parts[6])   // maxStudents (convert text to number)
                );
                // Set the initial enrolled students (convert text to number)
                course.setEnrolledStudents(Integer.parseInt(parts[5]));

                courses.add(course); // Add the new Course object to our list
            }
        } catch (IOException e) {
            System.err.println("Error loading courses: " + e.getMessage());
        }
    }

    // Method to find a course by its code
    public Course findCourse(String courseCode) {
        for (Course course : courses) { // Look through all courses
            if (course.getCourseCode().equals(courseCode)) {
                return course; // Return the Course object if code matches
            }
        }
        return null; // Return null if no course found with that code
    }

    // ... other methods like getAllCourses(), addCourse(), saveCourses() ...
}
```

This code is similar to `UserDatabase`. It reads the `courses.csv` file line by line. For each line, it splits the text by commas, takes the pieces of information, and uses them to create a `new Course` object. It then calls `setEnrolledStudents()` to make sure the current enrollment count is correct based on the file data. Finally, it adds the newly created `Course` object to a list kept in memory.

The `findCourse()` method shows how other parts of the system can ask the `CourseDatabase` for a specific course object if they know its code.

## How Home Screens get Course Information (Simple Flow)

Let's visualize how a page like `StudentHome` might get and display the list of courses, using the `CourseDatabase`.

```mermaid
sequenceDiagram
    participant StudentHome as StudentHome GUI
    participant CourseDatabase as CourseDatabase

    StudentHome->>CourseDatabase: Request all courses (e.g., getAllCourses())
    CourseDatabase-->>StudentHome: Return List of Course objects
    loop For each Course object in the List
        StudentHome->>CourseDatabase: (Not directly)<br/>Use Course object's getter methods<br/>(e.g., getCourseCode(), getTitle())
        Note over StudentHome: Display course details<br/>on the screen
    end
```

This diagram shows that the `StudentHome` doesn't need to worry about *how* the courses are stored or loaded; it just asks the `CourseDatabase` for the list of `Course` objects and then uses the methods of those objects to get the details it needs to show to the student.

## Connecting Courses to Other Concepts

*   **Courses and Users:** The `instructor` property of a `Course` links back to an `Instructor` user. When we create a timetable, we'll need to make sure an instructor isn't double-booked with two courses scheduled at the same `schedule`.
*   **Courses and TimeSlots:** The `schedule` string like "Mon 09:00-10:30" is human-readable. In a later chapter, we'll see how this schedule information is probably converted into a more structured `TimeSlot` object that the system can understand and use for checking conflicts when building a [Timetable](06_timetable_.md).
*   **Courses and Enrollment:** The `enrolledStudents` and `maxStudents` properties are directly related to the concept of [Enrollment](04_enrollment_.md), which tracks *which* student is signed up for *which* course. When a student enrolls in a course, the `enrolledStudents` count for that `Course` object needs to increase.

## Conclusion

In this chapter, we explored the **Course** concept, a fundamental building block in the `TimeTableMaker-BITS` system. We learned that a `Course` object represents a single class offering, holding details like its code, title, instructor, credits, schedule, and capacity. We saw how the `Course` class is defined in code and how the `CourseDatabase` is responsible for loading `Course` objects from a file and making them available to other parts of the system, like the `StudentHome` page. Understanding `Course` objects and their properties is essential as we move on to how students sign up for these courses.

[Next Chapter: Enrollment](04_enrollment_.md)

---

<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/data/courses.csv), [[2]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/data/CourseDatabase.java), [[3]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/models/Course.java)</sup></sub>



# Chapter 4: Enrollment

Welcome back! In the previous chapters, we learned about the system's entry points ([Chapter 1: GUI Pages (LoginPage, Home screens)](01_gui_pages__loginpage__home_screens__.md)), the different types of people who use the system ([Chapter 2: User (and roles)](02_user__and_roles__.md)), and the academic subjects offered ([Chapter 3: Course](03_course_.md)).

Now, let's connect these concepts. How do we know which specific student is taking which specific course? This is where the concept of **Enrollment** comes in.

## What is Enrollment?

Imagine "Enrollment" is like a signed permission slip. When a student decides they want to take a particular course, they essentially create an **Enrollment**. This slip says: "This student (identified by their username) is now officially signed up for this course (identified by its code)."

The `Enrollment` concept in our `TimeTableMaker-BITS` system acts as this digital "permission slip". It's a record that links a specific student to a specific course at a specific point in time, noting its current status.

Why do we need a separate concept for this?
*   A `Student` object knows *about* a student (their name, ID, etc.).
*   A `Course` object knows *about* a course (its title, schedule, etc.).
*   But neither of them, by themselves, tells you: "Student 'student1' is taking course 'CS101'".

The **Enrollment** is the missing piece that connects a particular `User` (specifically a `Student`) to a particular `Course`. It's the action of a student *joining* a course.

## The Enrollment Object in Code

In our code, an `Enrollment` is represented by a simple class: `Enrollment.java`. It holds the essential details of that "permission slip".

```java
// --- File: src/main/java/com/courseevaluation/models/Enrollment.java ---
package com.courseevaluation.models;

public class Enrollment {
    private String studentUsername; // Who is enrolled (links to User/Student)
    private String courseCode;    // Which course they are in (links to Course)
    private String enrollmentDate;  // When it happened
    private String status;        // Is it active? (e.g., "ENROLLED", "DROPPED")

    // This is how you create a new Enrollment object
    public Enrollment(String studentUsername, String courseCode, String enrollmentDate, String status) {
        this.studentUsername = studentUsername;
        this.courseCode = courseCode;
        this.enrollmentDate = enrollmentDate;
        this.status = status;
    }

    // Methods to get the details (getters)
    public String getStudentUsername() { return studentUsername; }
    public String getCourseCode() { return courseCode; }
    public String getEnrollmentDate() { return enrollmentDate; }
    public String getStatus() { return status; }

    // Method to change the status (like dropping)
    public void setStatus(String status) { this.status = status; }

    // Helper to format the data for saving (explained later)
    @Override
    public String toString() {
        return String.format("%s,%s,%s,%s", studentUsername, courseCode, enrollmentDate, status);
    }
}
```

As you can see, the `Enrollment` object is quite simple. It mainly acts as a link using the unique `studentUsername` and `courseCode`, and keeps track of the date and status.

## Where are Enrollments Stored? The EnrollmentDatabase

Like `User` and `Course` data, we need to store `Enrollment` records so they aren't lost when the program closes. These records are stored in a file and managed by the `EnrollmentDatabase` class.

The enrollment data is kept in `data/enrollments.csv`. Each line in this file represents one enrollment record.

Example from `data/enrollments.csv`:

```csv
student1,CS101,2025-04-14,ENROLLED
student1,CS102,2025-04-14,ENROLLED
student2,PH101,2025-04-15,ENROLLED
```
This example shows:
*   `student1` is enrolled in `CS101` since 2025-04-14.
*   `student1` is also enrolled in `CS102` since 2025-04-14.
*   `student2` is enrolled in `PH101` since 2025-04-15.

The `EnrollmentDatabase` is responsible for:
1.  Reading these lines when the application starts and creating `Enrollment` objects.
2.  Saving the current `Enrollment` objects back to the file when changes are made.
3.  Providing methods for other parts of the system (like `StudentHome`) to get enrollment information (e.g., "Give me all enrollments for student 'student1'").
4.  Handling the logic for a student enrolling or dropping a course.

## Loading Enrollments from the File

Let's see how the `EnrollmentDatabase` reads the data from `enrollments.csv`.

```java
// --- File: src/main/java/com/courseevaluation/data/EnrollmentDatabase.java ---
package com.courseevaluation.data;

import com.courseevaluation.models.Enrollment; // Need the Enrollment class
// ... other imports ...
import java.io.*; // For file handling
import java.util.ArrayList;
import java.util.List;

public class EnrollmentDatabase {
    private static final String FILE_PATH = "data/enrollments.csv";
    private List<Enrollment> enrollments; // List to hold all Enrollment objects
    // Also needs a reference to CourseDatabase! Why? Keep reading!
    private CourseDatabase courseDatabase;

    public EnrollmentDatabase(CourseDatabase courseDatabase) {
        this.enrollments = new ArrayList<>();
        this.courseDatabase = courseDatabase; // Store reference to CourseDatabase
        loadEnrollments(); // Load data when EnrollmentDatabase is created
    }

    private void loadEnrollments() {
        File file = new File(FILE_PATH);
        if (!file.exists()) { // If file doesn't exist yet, nothing to load
            return;
        }

        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split(","); // Split line by comma
                if (parts.length >= 4) { // Make sure the line has enough parts
                    // Create a new Enrollment object using parts from the file
                    enrollments.add(new Enrollment(
                        parts[0],  // studentUsername
                        parts[1],  // courseCode
                        parts[2],  // enrollmentDate
                        parts[3]   // status
                    ));
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading enrollments: " + e.getMessage());
        }
    }

    // ... methods to save, add, remove, get enrollments ...
}
```

Similar to other database classes, `EnrollmentDatabase` reads the CSV file line by line, splits the data, and uses it to create new `Enrollment` objects, adding them to an internal list.

Notice that `EnrollmentDatabase` also holds a reference to `CourseDatabase`. This is important because when a student enrolls or drops a course, we need to update the `enrolledStudents` count *in the corresponding `Course` object*. The `EnrollmentDatabase` will need to talk to the `CourseDatabase` to find the right `Course` and update it.

## Core Use Case: Enrolling in and Dropping a Course

Let's look at the main actions related to enrollment: a student adding (enrolling) or removing (dropping) a course. These actions are handled by methods within the `EnrollmentDatabase`.

### Enrolling a Student

When a student decides to enroll in a course, the system needs to:
1.  Create a new `Enrollment` record.
2.  Add this record to the list of enrollments.
3.  Increase the `enrolledStudents` count for the specific `Course` object.
4.  Save the changes to both the `enrollments.csv` and potentially `courses.csv` files.

Here's a simplified look at the `enrollStudent` method:

```java
// --- File: src/main/java/com/courseevaluation/data/EnrollmentDatabase.java ---
// ... inside EnrollmentDatabase class ...

public void enrollStudent(Student student, Course course) {
    // Optional check: Make sure student isn't already enrolled
    if (!isEnrolled(student, course)) { // isEnrolled is another method in this class
        // 1. Create a new Enrollment object
        Enrollment enrollment = new Enrollment(
            student.getUsername(),      // Get username from Student object
            course.getCourseCode(),     // Get code from Course object
            "CurrentDatePlaceholder", // Get today's date (using a helper utility)
            "ENROLLED"                  // Set status
        );

        // 2. Add the new enrollment record
        addEnrollment(enrollment); // addEnrollment adds to list and saves

        // 3. Update the Course object's enrollment count
        course.setEnrolledStudents(course.getEnrolledStudents() + 1);

        // 4. Save the updated Course information
        courseDatabase.saveCourses(); // Need CourseDatabase to save changes
    }
}

// Simplified addEnrollment method
public void addEnrollment(Enrollment enrollment) {
    enrollments.add(enrollment);
    saveEnrollments(); // Save to file immediately after adding
}
```

This method takes the `Student` and `Course` objects as input. It uses their unique identifiers (`username` and `courseCode`) to create a new `Enrollment` object. It adds this object to the internal list and saves the list to the file. Crucially, it then finds the `Course` object involved and updates its `enrolledStudents` count using the `setEnrolledStudents` method we saw in [Chapter 3](03_course_.md). Finally, it tells the `CourseDatabase` to save its data, which now includes the updated course information.

### Dropping a Course

When a student drops a course, the system needs to:
1.  Find the specific `Enrollment` record for that student and course.
2.  Remove that record (or maybe mark it as "DROPPED", although our code example removes it).
3.  Decrease the `enrolledStudents` count for the specific `Course` object.
4.  Save the changes to both files.

Here's a simplified look at the `dropCourse` method:

```java
// --- File: src/main/java/com/courseevaluation/data/EnrollmentDatabase.java ---
// ... inside EnrollmentDatabase class ...

public void dropCourse(Student student, Course course) {
    // We need to remove the specific enrollment record
    // The removeEnrollment method finds and removes the matching record
    removeEnrollment(new Enrollment( // Create a temporary Enrollment to search
        student.getUsername(),
        course.getCourseCode(),
        "", // Date doesn't matter for finding
        ""  // Status doesn't matter for finding
    ));

    // Decrease the Course object's enrollment count
    course.setEnrolledStudents(course.getEnrolledStudents() - 1);

    // Save the updated Course information
    courseDatabase.saveCourses(); // Tell CourseDatabase to save
}

// Simplified removeEnrollment method
public void removeEnrollment(Enrollment enrollmentToRemove) {
    // Remove from the list if studentUsername and courseCode match
    enrollments.removeIf(e ->
        e.getStudentUsername().equals(enrollmentToRemove.getStudentUsername()) &&
        e.getCourseCode().equals(enrollmentToRemove.getCourseCode()));
    saveEnrollments(); // Save to file immediately after removing
}
```

The `dropCourse` method also takes the `Student` and `Course` objects. It calls a helper method `removeEnrollment` to find and remove the relevant record from the list and file. Then, just like with enrollment, it updates the `enrolledStudents` count in the `Course` object and saves the course data.

## How Enrollment is Used in the GUI (Simplified Flow)

Let's visualize how the `StudentHome` page uses the `EnrollmentDatabase` to show a student their currently enrolled courses.

```mermaid
sequenceDiagram
    participant StudentHome as StudentHome GUI
    participant LoggedInStudent as Student Object
    participant EnrollmentDatabase as EnrollmentDatabase
    participant CourseDatabase as CourseDatabase
    participant CourseList as List of Course Objects

    StudentHome->>LoggedInStudent: Get username
    StudentHome->>EnrollmentDatabase: getEnrollmentsByStudent(username)
    EnrollmentDatabase-->>StudentHome: Return List of Enrollment objects
    Note over StudentHome: Loop through each Enrollment object<br/>to get courseCode
    StudentHome->>EnrollmentDatabase: getEnrolledCourses(LoggedInStudent)
    EnrollmentDatabase->>CourseDatabase: findCourse(courseCode) for each enrollment
    CourseDatabase-->>EnrollmentDatabase: Return Course objects
    EnrollmentDatabase-->>StudentHome: Return List of Course objects
    Note over StudentHome: Use Course objects' getters<br/>to display details (code, title, schedule, etc.)
```

This diagram shows a common interaction:
1.  The `StudentHome` page needs to display the student's courses.
2.  It asks the `EnrollmentDatabase` for a list of courses associated with the logged-in `Student` object.
3.  The `EnrollmentDatabase` looks through its `Enrollment` records. For each record belonging to the student, it gets the `courseCode`.
4.  The `EnrollmentDatabase` then uses its reference to the `CourseDatabase` to fetch the actual `Course` object for each `courseCode`.
5.  It returns a list of these `Course` objects to the `StudentHome` page.
6.  The `StudentHome` page then uses the details (like title, schedule) from the `Course` objects to display the student's timetable or list of enrolled courses.

This interaction highlights how `Enrollment` acts as the link, and the `EnrollmentDatabase` orchestrates getting the relevant `Course` information via the `CourseDatabase`.

## Conclusion

In this chapter, we learned about the crucial concept of **Enrollment** in the `TimeTableMaker-BITS` system. We saw that an `Enrollment` object is the record that connects a specific `Student` ([Chapter 2: User (and roles)](02_user__and_roles__.md)) to a specific `Course` ([Chapter 3: Course](03_course_.md)). We explored the `Enrollment` class and the `EnrollmentDatabase`, which manages these records by loading them from and saving them to a file. We also saw how the `EnrollmentDatabase` handles the core actions of students enrolling in or dropping courses, updating both the enrollment records and the corresponding `Course` objects. This understanding of who is taking what course is fundamental to the next steps: figuring out *when* those courses meet to build a timetable.

[Next Chapter: TimeSlot](05_timeslot_.md)

---

<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/data/enrollments.csv), [[2]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/data/EnrollmentDatabase.java), [[3]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/models/Enrollment.java)</sup></sub>



# Chapter 5: TimeSlot

Welcome back to the `TimeTableMaker-BITS` tutorial! In the last chapter, [Chapter 4: Enrollment](04_enrollment_.md), we learned how the system keeps track of which student is signed up for which course using the **Enrollment** concept.

We know who the users are, what courses are available, and which students are taking which courses. But the big question remains: **When** do these courses actually meet?

The `Course` object we saw in [Chapter 3: Course](03_course_.md) does have a `schedule` property, like "Mon 09:00-10:30". While this string is easy for humans to read, it's not very useful for the computer to figure out if two courses clash. For example, how does the computer know that "Mon 09:00-10:30" and "Mon 10:00-11:30" overlap? It needs a more structured way to represent these time blocks.

This is exactly the problem the **TimeSlot** concept solves!

## What is a TimeSlot?

Think of a **TimeSlot** as a digital building block that represents one specific block of time on a particular day when a single course is scheduled to meet. It's like putting a single appointment onto a calendar for a specific purpose (the course).

A `TimeSlot` object holds the precise details about *when* and *where* a class session happens *for a particular course*. Specifically, it knows:

*   **Which Day:** (e.g., "Mon", "Tue")
*   **Start Time:** (e.g., "09:00")
*   **End Time:** (e.g., "10:30")
*   **Which Course:** The `Course` object that is scheduled during this time.

So, instead of just a string like "Mon 09:00-10:30", the system can create a `TimeSlot` object that specifically represents the class for, say, "CS101" happening on Monday from 9:00 AM to 10:30 AM.

The most important thing a `TimeSlot` can do is check if it conflicts or **overlaps** with another `TimeSlot`. This is essential for building a valid timetable!

## The TimeSlot Object in Code

In our project, the `TimeSlot` concept is represented by the `TimeSlot.java` class.

```java
// --- File: src/main/java/com/courseevaluation/models/TimeSlot.java ---
package com.courseevaluation.models;

public class TimeSlot {
    private String day;      // Like "Mon", "Tue"
    private String startTime; // Like "09:00"
    private String endTime;   // Like "10:30"
    private Course course;   // Reference to the Course object

    // This is how we create a new TimeSlot object
    public TimeSlot(String day, String startTime, String endTime, Course course) {
        this.day = day;
        this.startTime = startTime;
        this.endTime = endTime;
        this.course = course;
    }

    // Getters to access the information stored in the TimeSlot
    public String getDay() { return day; }
    public String getStartTime() { return startTime; }
    public String getEndTime() { return endTime; }
    public Course getCourse() { return course; } // Returns the associated Course object

    // ... methods to check for overlaps (explained next) ...

    // How the TimeSlot looks when printed (helpful for testing)
    @Override
    public String toString() {
        return day + " " + startTime + "-" + endTime + " " + course.getCourseCode();
    }
}
```

This code shows the simple blueprint for a `TimeSlot`. When you create one, you provide the day, start time, end time, and the `Course` object it belongs to. The getter methods allow other parts of the program to easily access this information.

## The Core Power: Checking for Overlaps

The main reason we created the `TimeSlot` concept is so the system can reliably detect scheduling conflicts. A student (or instructor) cannot be in two places at the same time! The `overlaps()` method within the `TimeSlot` class is designed to check just this.

The logic for `overlaps` is:
1.  Two `TimeSlot` objects can only overlap if they are on the **same day**.
2.  If they are on the same day, they overlap if one time range begins *before* the other time range ends, AND the other time range begins *before* the first one ends.

Let's look at the code for the `overlaps` method:

```java
// --- File: src/main/java/com/courseevaluation/models/TimeSlot.java ---
// ... inside TimeSlot class, after getters ...

public boolean overlaps(TimeSlot other) {
    // 1. Check if they are on the same day
    if (!this.day.equals(other.day)) {
        return false; // Different days means no overlap
    }

    // To check time overlap easily, convert times to a single number (like minutes)
    int thisStart = convertTimeToMinutes(this.startTime);
    int thisEnd = convertTimeToMinutes(this.endTime);
    int otherStart = convertTimeToMinutes(other.startTime);
    int otherEnd = convertTimeToMinutes(other.endTime);

    // 2. Check if the time ranges overlap on the same day
    // They overlap if: (This one starts before Other one ends) AND (This one ends after Other one starts)
    return (thisStart < otherEnd && thisEnd > otherStart);
}

// Helper method to turn "HH:mm" into total minutes from midnight
private int convertTimeToMinutes(String time) {
    String[] parts = time.split(":"); // Split "09:00" into ["09", "00"]
    int hours = Integer.parseInt(parts[0]); // Convert "09" to 9
    int minutes = Integer.parseInt(parts[1]); // Convert "00" to 0
    return hours * 60 + minutes; // 9 hours * 60 minutes/hour + 0 minutes = 540
}

// ... rest of the TimeSlot class ...
```

The `overlaps()` method first checks the day. If the days are different, there's no conflict, so it immediately returns `false`. If the days are the same, it uses a helper method `convertTimeToMinutes` to turn the "HH:mm" time strings into a single number representing the total minutes past midnight. This makes comparing times much simpler. For example, "09:00" becomes 540 minutes, "10:30" becomes 630 minutes.

The core logic `(thisStart < otherEnd && thisEnd > otherStart)` is a standard way to check if two ranges (like time ranges on a timeline) overlap.

## How TimeSlots are Used (Briefly Introducing Timetable)

`TimeSlot` objects are the building blocks for a **Timetable**. A **Timetable** object (which we'll cover in detail in the next chapter, [Chapter 6: Timetable](06_timetable_.md)) is essentially a collection of `TimeSlot` objects.

When the system wants to add a new course to a timetable (either a student's personal one or an overall one), it:
1.  Takes the `schedule` string from the `Course` object (like "Mon 09:00-10:30").
2.  Parses that string to get the day ("Mon"), start time ("09:00"), and end time ("10:30").
3.  Creates a new `TimeSlot` object using these details and the `Course` object.
4.  Before adding this new `TimeSlot` to the `Timetable`, it checks if this new `TimeSlot` `overlaps()` with *any* of the existing `TimeSlot` objects already in the `Timetable`.
5.  If there's an overlap (`overlaps()` returns `true` for any existing slot), the new slot cannot be added because it causes a conflict.
6.  If there's no overlap (`overlaps()` returns `false` for all existing slots), the new `TimeSlot` is added to the `Timetable`.

This check is crucial for ensuring that generated or manually added timetables are valid and free of double-bookings.

Here's a simplified look at this interaction using a diagram:

```mermaid
sequenceDiagram
    participant Timetable as Timetable Object
    participant NewCourse as Course (e.g. CS201)
    participant NewTimeSlot as TimeSlot Object
    participant ExistingSlot as Existing TimeSlot (e.g. CS101)

    Note over Timetable: Try to add CS201 (Mon 10:30-12:00)
    Timetable->>NewCourse: Get schedule string<br/>("Mon 10:30-12:00")
    Timetable->>NewTimeSlot: Create new TimeSlot(Mon, 10:30, 12:00, CS201)
    Note over Timetable: Loop through existing TimeSlots<br/>in the timetable
    Timetable->>ExistingSlot: Check for overlap?<br/>overlaps(NewTimeSlot)
    ExistingSlot-->>Timetable: Return true or false<br/>(e.g., false if ExistingSlot is Tue 09:00, true if Mon 10:00)
    alt If overlap is found
        Timetable->>Timetable: Conflict detected! Do not add NewTimeSlot.
    else If NO overlap with any existing slot
        Timetable->>Timetable: Add NewTimeSlot to list of slots.
    end
```

This diagram shows how the `Timetable` object relies on the `TimeSlot` object's ability to check for overlaps.

## Where are TimeSlots Stored?

Unlike Users, Courses, and Enrollments, **TimeSlot objects are typically not stored in a dedicated database file like a CSV.** Why? Because they represent *instances* of when a course meets within a *specific* timetable context.

The primary source of scheduling information is the `schedule` string stored in the `Course` object ([Chapter 3: Course](03_course_.md)). When a timetable is needed (either a student's or a generated one), the system reads the relevant `Course` objects, parses their schedule strings, and *creates* `TimeSlot` objects in memory. These `TimeSlot` objects exist temporarily to allow the `Timetable` object to perform conflict checks and be displayed. They are part of the `Timetable` object itself, not stored separately as persistent data.

You can see this in the `Timetable.generateTimetable()` method snippet from the provided code:

```java
// --- File: src/main/java/com/courseevaluation/models/Timetable.java ---
// ... inside generateTimetable method ...

    // ... loop through courses ...
    // First try the course's preferred schedule
    if (course.getSchedule() != null && !course.getSchedule().isEmpty()) {
        String[] scheduleParts = course.getSchedule().split(" "); // Split "Mon 09:00-10:30"
        String day = scheduleParts[0]; // "Mon"
        String timeSlot = scheduleParts[1]; // "09:00-10:30"

        // Split "09:00-10:30" into start and end times
        TimeSlot slot = new TimeSlot(day, timeSlot.split("-")[0], timeSlot.split("-")[1], course);

        // Use the TimeSlot object to check for conflicts
        if (!timetable.hasConflict(slot)) {
            timetable.addTimeSlot(slot); // Add if no conflict
            scheduled = true;
        }
    }
    // ... (rest of scheduling logic) ...
```

This snippet shows that the `generateTimetable` method takes the `schedule` string from a `Course`, extracts the day and time parts, and then directly creates a `new TimeSlot()` object *in memory* using those parts and the `course` object. This `TimeSlot` object is then used for the conflict check (`!timetable.hasConflict(slot)`) and added to the `timetable` object's internal list.

So, `TimeSlot` objects are created and used *as needed* when building or working with timetables, based on the schedule data already present in the `Course` objects.

## Connecting TimeSlot to Other Concepts

*   **TimeSlot and Course:** A `TimeSlot` always belongs to a specific `Course`. The `TimeSlot` object holds a reference to the `Course` it represents. The `Course` object's `schedule` string is the raw data used to *create* `TimeSlot` objects.
*   **TimeSlot and Timetable:** `TimeSlot` objects are the fundamental components that make up a `Timetable`. A `Timetable` is essentially a collection of `TimeSlot`s, and it relies on the `TimeSlot`'s `overlaps()` method to ensure validity.

## Conclusion

In this chapter, we introduced the **TimeSlot** concept. We learned that a `TimeSlot` object provides a structured way to represent a specific block of time on a given day when a course meets, moving beyond simple text descriptions. The key ability of a `TimeSlot` is to check if it **overlaps** with another `TimeSlot`, which is vital for detecting scheduling conflicts. We saw how `TimeSlot` objects are created dynamically from the `schedule` information in a `Course` and are used as building blocks within a **Timetable**. Understanding `TimeSlot` is essential for grasping how valid schedules are constructed and managed in the system.

[Next Chapter: Timetable](06_timetable_.md)

---

<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/models/TimeSlot.java), [[2]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/models/Timetable.java)</sup></sub>



# Chapter 6: Timetable

Welcome back! In our journey through the `TimeTableMaker-BITS` project, we've learned about the different users ([Chapter 2: User (and roles)](02_user__and_roles__.md)), the courses they interact with ([Chapter 3: Course](03_course_.md)), how students are linked to courses through enrollment records ([Chapter 4: Enrollment](04_enrollment_.md)), and the specific time blocks when courses meet ([Chapter 5: TimeSlot](05_timeslot_.md)).

Now, let's put it all together. What is the main output of a system like this? It's a schedule! For a student, it's their personal list of classes and when they meet. For the university, it's the grand plan of all courses being offered at specific times. This collection of scheduled class times is called a **Timetable**.

## What is a Timetable?

Think of a **Timetable** as your weekly class schedule written out. It's not just a list of courses; it's a collection of *when* and *where* those courses actually happen.

In our `TimeTableMaker-BITS` system, a `Timetable` object is essentially a container that holds a bunch of **TimeSlot** objects ([Chapter 5: TimeSlot](05_timeslot_.md)). Each `TimeSlot` in the `Timetable` represents one scheduled meeting time for a specific course.

The main purpose of a `Timetable` is to:

1.  Keep track of all the scheduled `TimeSlot`s.
2.  Provide a way to **check for conflicts** between existing `TimeSlot`s and any new `TimeSlot` you might want to add.
3.  Potentially include logic to **automatically build** a conflict-free schedule from a list of courses.

It's the central structure that ensures a set of classes can actually be taken without being double-booked.

## The Timetable Object in Code

In our project, the `Timetable` concept is represented by the `Timetable.java` class in the `models` package. Its core is a list of `TimeSlot` objects.

```java
// --- File: src/main/java/com/courseevaluation/models/Timetable.java ---
package com.courseevaluation.models;

import java.util.*; // For List and ArrayList

public class Timetable {
    // This list holds all the TimeSlot objects that make up the timetable
    private List<TimeSlot> timeSlots;

    // When a new Timetable is created, start with an empty list
    public Timetable() {
        this.timeSlots = new ArrayList<>();
    }

    // Method to add a TimeSlot to the timetable
    public void addTimeSlot(TimeSlot timeSlot) {
        // IMPORTANT: Only add if there's no conflict!
        if (!hasConflict(timeSlot)) {
            timeSlots.add(timeSlot);
        } else {
             // Optional: could print a message or return false
             System.out.println("Conflict adding " + timeSlot.getCourse().getCourseCode() +
                                " at " + timeSlot.getDay() + " " + timeSlot.getStartTime());
        }
    }

    // Method to check if adding a new slot would cause a conflict
    public boolean hasConflict(TimeSlot newSlot) {
        // Loop through all existing TimeSlot objects in our list
        for (TimeSlot existingSlot : timeSlots) {
            // Use the overlaps method from the TimeSlot class
            if (existingSlot.overlaps(newSlot)) {
                return true; // Found an overlap, so there is a conflict!
            }
        }
        return false; // No overlaps found with any existing slot
    }

    // Method to get a list of all time slots in this timetable
    public List<TimeSlot> getTimeSlots() {
        // Return a copy to prevent external code from modifying the list directly
        return new ArrayList<>(timeSlots);
    }

    // ... other methods, like getting slots for a specific day ...
}
```

This simplified code shows the essential parts. The `Timetable` class maintains a `List` of `TimeSlot`s. The `addTimeSlot()` method is the way you put new scheduled times into the timetable, but it *always* checks `hasConflict()` first. The `hasConflict()` method is the core logic: it goes through each `TimeSlot` it already holds and asks that `TimeSlot` if it `overlaps()` ([Chapter 5: TimeSlot](05_timeslot_.md)) with the proposed new slot. If even one overlap is found, `hasConflict` returns `true`, and `addTimeSlot` prevents the addition.

## Building a Timetable: From Courses to TimeSlots

How do we get `TimeSlot` objects into a `Timetable`? They come from the `Course` objects ([Chapter 3: Course](03_course_.md)) that contain the schedule information.

Imagine you have a list of `Course` objects you want to schedule for a student (these would be the courses they are [Enrolled](04_enrollment_.md) in).

The process to build their timetable in memory would look something like this:

1.  Create an empty `Timetable` object.
2.  Get the list of `Course` objects the student is taking.
3.  Loop through each `Course` in the list.
4.  For each `Course`, get its `schedule` string (like "Mon 09:00-10:30").
5.  **Parse** that string to get the day ("Mon"), start time ("09:00"), and end time ("10:30").
6.  Create a new `TimeSlot` object using the parsed day, times, and the `Course` object itself.
7.  Try to add this new `TimeSlot` to the `Timetable` using the `addTimeSlot()` method. The `Timetable` will automatically check for conflicts.
8.  If `addTimeSlot` succeeds (because there was no conflict), the `TimeSlot` is added. If it fails (because there was a conflict), it means the student is scheduled for two things at once based on the courses provided â€“ this is a problem that needs to be resolved!

Here's a sequence diagram showing this process for building a timetable:

```mermaid
sequenceDiagram
    participant StudentHome as StudentHome GUI
    participant EnrolledCourses as List of Courses
    participant MyTimetable as Timetable Object
    participant Course as Course Object
    participant TimeSlot as TimeSlot Object

    Note over StudentHome: Needs to display student schedule
    StudentHome->>EnrolledCourses: Get list of enrolled Course objects
    StudentHome->>MyTimetable: Create new empty Timetable()
    loop For each Course in EnrolledCourses
        StudentHome->>Course: Get schedule string (e.g. "Mon 09:00-10:30")
        StudentHome->>TimeSlot: Parse string & Create new TimeSlot()
        StudentHome->>MyTimetable: addTimeSlot(TimeSlot)
        MyTimetable->>MyTimetable: hasConflict(TimeSlot)
        MyTimetable->>TimeSlot: overlaps(...) check
        TimeSlot-->>MyTimetable: Return true or false
        alt If no conflict
            MyTimetable->>MyTimetable: Add TimeSlot to internal list
        else If conflict
            MyTimetable->>MyTimetable: Do not add TimeSlot
        end
    end
    StudentHome-->>MyTimetable: Get list of valid TimeSlots (getTimeSlots())
    Note over StudentHome: Display the TimeSlots<br/>on the screen (using TimetablePanel)
```

This diagram illustrates how the GUI (like `StudentHome`) uses a list of `Course` objects to populate a `Timetable` object in memory, relying on the `TimeSlot`'s `overlaps` method and the `Timetable`'s `hasConflict` and `addTimeSlot` methods to correctly build a valid schedule representation.

## Automatic Timetable Generation

Besides just checking for conflicts when adding slots, the `Timetable` class includes more complex logic to try and build a *full* conflict-free timetable automatically from a list of available courses. This is useful for suggesting schedules to students.

The `generateTimetable` method is responsible for this. It takes a list of courses and attempts to fit as many as possible into predefined time slots (`Mon 09:00-10:30`, etc.) without conflicts.

```java
// --- File: src/main/java/com/courseevaluation/models/Timetable.java ---
// ... inside Timetable class ...

    public static Timetable generateTimetable(List<Course> courses, List<String> preferences) {
        Timetable timetable = new Timetable(); // Start with an empty timetable
        List<Course> availableCourses = new ArrayList<>(courses);

        // ... (Code here to shuffle/sort courses - trying different orders) ...

        // Try to schedule each course from the list
        for (Course course : availableCourses) {
            boolean scheduled = false;

            // --- Simplified scheduling attempt ---
            // Just try the course's preferred schedule from the Course object
            if (course.getSchedule() != null && !course.getSchedule().isEmpty()) {
                String[] scheduleParts = course.getSchedule().split(" "); // Split "Mon 09:00-10:30"
                String day = scheduleParts[0];
                String timeSlotString = scheduleParts[1];
                String[] times = timeSlotString.split("-"); // Split "09:00-10:30"

                // Create the TimeSlot object for this schedule
                TimeSlot slot = new TimeSlot(day, times[0], times[1], course);

                // Check if this slot conflicts with anything already scheduled
                if (!timetable.hasConflict(slot)) {
                    timetable.addTimeSlot(slot); // If no conflict, add it!
                    scheduled = true; // Mark as scheduled
                }
            }
            // ... (Code here to try alternative time slots if the preferred didn't work) ...

            // If the course couldn't be scheduled in any slot without conflict, it's skipped.
        }

        return timetable; // Return the timetable that was built
    }

    // ... generateMultipleTimetables method (calls generateTimetable multiple times) ...
}
```

This snippet from `generateTimetable` shows the core loop: it takes a `Course`, parses its schedule (or tries various predefined slots), creates a `TimeSlot`, uses the `timetable.hasConflict()` method to check if that slot can be added without clashing with courses *already successfully added* to this `timetable`. If there's no conflict, it adds the `TimeSlot` to the `timetable`. This process is repeated for all courses, building up the `timetable` one conflict-free `TimeSlot` at a time.

The `generateMultipleTimetables` method is a variation that runs `generateTimetable` several times (because the course order is shuffled) to find different possible valid timetable combinations.

## Where are Timetables Stored?

Similar to `TimeSlot` objects ([Chapter 5: TimeSlot](05_timeslot_.md)), **Timetable objects themselves are typically not stored persistently in a file like a CSV.**

*   A student's personal timetable is usually built **in memory** when they log in and view their schedule. The system looks at their [Enrollments](04_enrollment_.md), finds the corresponding [Courses](03_course_.md), and uses the schedule information from those courses to create the necessary `TimeSlot` objects and assemble them into a `Timetable` object for display.
*   Automatically generated timetables (like those produced by `generateTimetable`) are results calculated **in memory**. They might be displayed to the user or used for analysis, but they aren't usually saved back to a dedicated "timetables.csv" file. The raw data (Users, Courses, Enrollments) is what is saved persistently.

The `Timetable` object is more of a temporary data structure used during the program's execution to model and validate a schedule based on the persistent course and enrollment data.

The `TimetablePanel` class in the `gui` package (part of the provided code, though not detailed in previous chapters) is the visual component that *displays* a `Timetable` to the user, but the `TimetablePanel` itself doesn't hold the timetable data persistently; it receives a list of `Course` objects (or potentially a `Timetable` object) and renders it visually.

## Connecting Timetable to Other Concepts

*   **Timetable and TimeSlot:** `TimeSlot` objects are the fundamental components contained within a `Timetable`. The `Timetable` relies on the `TimeSlot`'s `overlaps` method.
*   **Timetable and Course:** The `schedule` information from `Course` objects is used to *create* the `TimeSlot`s that populate a `Timetable`. A student's timetable is built from the courses they are taking.
*   **Timetable and Enrollment:** Enrollment records determine *which* courses belong to a student, and thus which courses are used to build that student's personal `Timetable`.
*   **Timetable and GUI:** The `TimetablePanel` GUI component displays the information contained within a `Timetable` object (or derived from the courses that make up the timetable) in a user-friendly visual format.

## Conclusion

In this chapter, we learned about the **Timetable** concept, which is a core output of the `TimeTableMaker-BITS` system. We saw that a `Timetable` object manages a collection of **TimeSlot** objects ([Chapter 5: TimeSlot](05_timeslot_.md)) and, importantly, provides the crucial logic to check for scheduling conflicts using the `hasConflict` method, which in turn relies on the `TimeSlot`'s `overlaps` method. We also briefly touched upon how Timetables can be automatically generated from a list of courses. Understanding the `Timetable` object is key to seeing how the system ensures valid schedules.

With our understanding of users, courses, enrollments, time slots, and how they come together in a timetable, the final piece of the puzzle is understanding how all this data is stored and managed persistently so it's available every time the application runs.

[Next Chapter: Database Classes (UserDatabase, CourseDatabase, EnrollmentDatabase)](07_database_classes__userdatabase__coursedatabase__enrollmentdatabase__.md)

---

<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/gui/TimetablePanel.java), [[2]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/models/TimeSlot.java), [[3]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/models/Timetable.java)</sup></sub>




# Chapter 7: Database Classes (UserDatabase, CourseDatabase, EnrollmentDatabase)

Welcome back to the final chapter of our introductory tutorial for `TimeTableMaker-BITS`! We've covered the user interface ([Chapter 1: GUI Pages (LoginPage, Home screens)](01_gui_pages__loginpage__home_screens__.md)), the people using the system ([Chapter 2: User (and roles)](02_user__and_roles__.md)), the things they interact with ([Chapter 3: Course](03_course_.md) and [Chapter 4: Enrollment](04_enrollment_.md)), and how schedules are represented ([Chapter 5: TimeSlot](05_timeslot_.md) and [Chapter 6: Timetable](06_timetable_.md)).

All these concepts â€“ Users, Courses, and Enrollments â€“ represent information that the system needs to remember. If you add a new user or a student enrolls in a course, you wouldn't want that information to disappear every time you close the application!

This is where the **Database Classes** come in. They are responsible for making sure our system's data **persists** (meaning it survives even after the program stops running).

## What are Database Classes? The System's Librarians

Imagine our `TimeTableMaker-BITS` application is like a small office. We have different desks for different tasks (the GUI pages). We have different types of people working there (the Users with roles). We have files describing the work (Courses). And we have records of who is working on which file (Enrollments).

But where do we keep all the actual papers and documents when nobody is using them? In filing cabinets or a library!

Our **Database Classes** are like the dedicated librarians or filing cabinet managers for our data. Each database class is specialized in handling one specific type of information:

*   **`UserDatabase`:** Manages all the `User` information (including Students, Instructors, and Admins).
*   **`CourseDatabase`:** Manages all the `Course` information.
*   **`EnrollmentDatabase`:** Manages all the `Enrollment` records, connecting students to courses.

Their main jobs are:
1.  **Loading Data:** When the application starts, they read the information from special files and bring it into the computer's memory so the program can use it.
2.  **Storing Data (In Memory):** While the application is running, they hold onto the lists of `User`, `Course`, and `Enrollment` objects. Other parts of the program ask these database classes for the data they need.
3.  **Saving Data:** When changes are made (like adding a new user, creating a course, or a student enrolling), these classes are responsible for writing the updated information back to the special files so the changes are saved permanently.

## Why Files? (Using CSV)

Large, complex applications often use sophisticated database systems (like SQL databases). However, for a smaller project like this, using simple text files is a common and easier approach to get started with data persistence.

Our `TimeTableMaker-BITS` project uses **CSV (Comma Separated Values)** files. These are just text files where each line represents one record (like one user or one course), and the different pieces of information on that line are separated by commas.

We've already seen examples of these files in previous chapters:
*   `data/users.csv` stores user data.
*   `data/courses.csv` stores course data.
*   `data/enrollments.csv` stores enrollment data.

The database classes know how to read these specific CSV formats and how to write information back into them correctly.

## The Three Database Classes in Detail

Let's look at each database class and its role.

### UserDatabase: Managing User Accounts

The `UserDatabase` is the librarian for our users. It knows about everyone who can log into the system.

**Core Job:** Load users from `users.csv` on startup, keep a list of `User` objects, provide methods to find users, add users, and save the list back to the file.

**Loading Users:** When the application starts, the `UserDatabase` object is created, and it immediately calls a method to read `users.csv`.

```java
// --- File: src/main/java/com/courseevaluation/data/UserDatabase.java ---
// ... imports and class definition ...

private List<User> users; // This list holds all User objects in memory

public UserDatabase() {
    users = new ArrayList<>(); // Create an empty list
    loadUsers(); // Call the method to read the file and fill the list
}

private void loadUsers() {
    // Read the users.csv file line by line
    // For each line, split the parts (using comma as separator)
    // Look at the first part (which is the role type)
    // Create a new Student, Instructor, or Admin object based on the role
    // Add the new User object to the 'users' list
    // Handle potential errors if the file is missing or corrupted
    // (Simplified for clarity, actual code has file reading logic)
}

// ... other methods like saveUsers(), findUser(), addUser(), getAllUsers() ...
```

This simplified view shows that the `UserDatabase` holds a list (`users`) and fills it by calling `loadUsers()` when it's created. The `loadUsers` method reads the file, figures out the type of user from the data, creates the correct object ([Chapter 2: User (and roles)](02_user__and_roles__.md)), and adds it to the list.

**Saving Users:** When an Administrator adds a new user, for example, they interact with the system in a way that ultimately calls a method in `UserDatabase` (like `addUser`). After adding the user to its internal list, the `UserDatabase` calls `saveUsers()` to write *all* current users back to the `users.csv` file, overwriting the old content.

```java
// --- File: src/main/java/com/courseevaluation/data/UserDatabase.java ---
// ... inside UserDatabase class ...

public void saveUsers() {
    // Open the users.csv file for writing (this usually clears the existing content)
    // Loop through every User object currently in the 'users' list
    // For each User object, get its data in a CSV format (often using a toString() method on the User/Student/Instructor/Admin classes)
    // Write that formatted line to the file
    // Handle potential errors during writing
    // (Simplified for clarity, actual code has file writing logic)
}

public void addUser(User user) {
    users.add(user); // Add the new user object to the list
    saveUsers(); // Immediately save the entire updated list back to the file
}

// ... findUser(), getAllUsers() ...
```

The `saveUsers` method iterates through the `users` list and writes each `User` object's data to the file. The `addUser` method demonstrates that after modifying the list, `saveUsers` is called to make the change permanent. (Note: the actual `User`, `Student`, `Instructor`, `Admin` classes need a `toString()` method that formats their data into the correct CSV line for saving, as hinted in the `saveUsers` method).

**How other parts use it:** The `LoginPage` ([Chapter 1: GUI Pages (LoginPage, Home screens)](01_gui_pages__loginpage__home_screens__.md)) uses `findUser` to check login credentials. The `AdminHome` page might use `getAllUsers` to display a list of users or `addUser` to create new accounts.

Here's a simple interaction diagram for the login scenario:

```mermaid
sequenceDiagram
    participant LP as LoginPage
    participant UD as UserDatabase
    participant UserObj as User Object (in memory)

    Note over LP: User enters credentials
    LP->>UD: findUser("username")
    UD->>UD: Search 'users' list for username
    UD-->>LP: Return matching UserObj (or null)
    Note over LP: Check password and role on UserObj
    alt Successful Login
        LP->>UD: (Not directly needed after finding user)
        Note over LP: Proceed to Home Screen
    else Failed Login
        Note over LP: Show error message
    end
```

### CourseDatabase: Managing Course Offerings

The `CourseDatabase` is the librarian for courses. It keeps track of all available subjects.

**Core Job:** Load courses from `courses.csv` on startup, keep a list of `Course` objects, provide methods to find courses, add courses, and save the list back to the file.

**Loading & Saving Courses:** This works very similarly to `UserDatabase`, but with `Course` objects and the `courses.csv` file format ([Chapter 3: Course](03_course_.md)).

```java
// --- File: src/main/java/com/courseevaluation/data/CourseDatabase.java ---
// ... imports and class definition ...

private List<Course> courses; // This list holds all Course objects in memory

public CourseDatabase() {
    courses = new ArrayList<>(); // Create an empty list
    loadCourses(); // Load courses from file
}

private void loadCourses() {
    // Read courses.csv line by line
    // Split parts by comma
    // Create new Course object using the parts
    // Add Course object to the 'courses' list
    // (Simplified)
}

public void saveCourses() {
    // Open courses.csv for writing
    // Loop through 'courses' list
    // Get CSV format for each Course (using Course's toString())
    // Write line to file
    // (Simplified)
}

// ... methods like findCourse(), getAllCourses(), addCourse(), getCoursesByInstructor() ...
```

**How other parts use it:** The `StudentHome` page ([Chapter 1: GUI Pages (LoginPage, Home screens)](01_gui_pages__loginpage__home_screens__.md)) uses `getAllCourses` or `findCourse` to display available courses or details of a specific course. The `AdminHome` page uses methods to add or potentially modify course information (which would also require a `saveCourses` call). The `EnrollmentDatabase` also needs to find `Course` objects to update their enrollment counts, as we'll see next.

Simple interaction example: Student Home displaying courses.

```mermaid
sequenceDiagram
    participant SH as StudentHome GUI
    participant CD as CourseDatabase
    participant CourseList as List of Course Objects

    SH->>CD: getAllCourses()
    CD->>CD: Retrieve 'courses' list
    CD-->>SH: Return CourseList
    Note over SH: Loop through CourseList<br/>and display details<br/>using Course object getters
```

### EnrollmentDatabase: Managing Student-Course Links

The `EnrollmentDatabase` is the librarian for the records connecting students to courses.

**Core Job:** Load enrollment records from `enrollments.csv` on startup, keep a list of `Enrollment` objects, provide methods to find enrollments (by student or course), add new enrollments, remove enrollments, and save the list back to the file. Crucially, it also works closely with `CourseDatabase` to update enrollment counts.

**Loading & Saving Enrollments:** Similar file reading/writing logic applies to `enrollments.csv` and `Enrollment` objects ([Chapter 4: Enrollment](04_enrollment_.md)).

```java
// --- File: src/main/java/com/courseevaluation/data/EnrollmentDatabase.java ---
// ... imports and class definition ...

private List<Enrollment> enrollments; // List of Enrollment objects
private CourseDatabase courseDatabase; // Needs access to CourseDatabase!

public EnrollmentDatabase(CourseDatabase courseDatabase) {
    this.enrollments = new ArrayList<>();
    this.courseDatabase = courseDatabase; // Store the reference
    loadEnrollments(); // Load enrollments from file
}

private void loadEnrollments() {
    // Read enrollments.csv line by line
    // Split parts by comma
    // Create new Enrollment object
    // Add Enrollment object to the 'enrollments' list
    // (Simplified)
}

public void saveEnrollments() {
    // Open enrollments.csv for writing
    // Loop through 'enrollments' list
    // Get CSV format for each Enrollment (using Enrollment's toString())
    // Write line to file
    // (Simplified)
}

// ... methods like getEnrollmentsByStudent(), enrollStudent(), dropCourse(), etc. ...
```

Notice the `EnrollmentDatabase`'s constructor takes a `CourseDatabase` object. This is dependency injection â€“ the `EnrollmentDatabase` *depends* on being able to talk to the `CourseDatabase` to do its job fully (specifically, to update course enrollment counts when students enroll or drop).

**Handling Enroll/Drop:** These are key actions that involve both the `EnrollmentDatabase` and the `CourseDatabase`.

When a student enrolls:
1.  A new `Enrollment` object is created.
2.  The `EnrollmentDatabase` adds it to its list and calls `saveEnrollments`.
3.  The `EnrollmentDatabase` finds the related `Course` object using its `courseDatabase` reference (`courseDatabase.findCourse(...)`).
4.  It updates the `enrolledStudents` count on that `Course` object (`course.setEnrolledStudents(...)`).
5.  It tells the `courseDatabase` to save its updated list (`courseDatabase.saveCourses()`).

```java
// --- File: src/main/java/com/courseevaluation/data/EnrollmentDatabase.java ---
// ... inside EnrollmentDatabase class ...

public void enrollStudent(Student student, Course course) {
    // Create the Enrollment object (simplified date)
    Enrollment enrollment = new Enrollment(student.getUsername(), course.getCourseCode(), "SomeDate", "ENROLLED");

    addEnrollment(enrollment); // Add to our list and save enrollments

    // Update course enrollment count AND tell CourseDatabase to save
    course.setEnrolledStudents(course.getEnrolledStudents() + 1);
    courseDatabase.saveCourses(); // Save the courses file!
}

// The addEnrollment method adds to list and calls saveEnrollments()
public void addEnrollment(Enrollment enrollment) {
    enrollments.add(enrollment);
    saveEnrollments();
}
// ... dropCourse method works similarly, decreasing count and saving both ...
```

The `dropCourse` method works in a similar way, removing the enrollment record and decreasing the course's enrollment count, then saving both databases.

**How other parts use it:** The `StudentHome` page uses `getEnrollmentsByStudent` or `getEnrolledCourses` to show the student's current schedule. It also calls `enrollStudent` and `dropCourse` when the student uses the corresponding buttons on the GUI.

Here's a diagram showing the enroll interaction:

```mermaid
sequenceDiagram
    participant SH as StudentHome GUI
    participant ED as EnrollmentDatabase
    participant CD as CourseDatabase
    participant StudentObj as Student Object
    participant CourseObj as Course Object
    participant EnrollmentObj as Enrollment Object

    Note over SH: Student clicks Enroll button
    SH->>ED: enrollStudent(StudentObj, CourseObj)
    ED->>EnrollmentObj: Create new EnrollmentObj
    ED->>ED: Add EnrollmentObj to 'enrollments' list
    ED->>ED: saveEnrollments()
    ED->>CourseObj: setEnrolledStudents(+1)
    ED->>CD: saveCourses()
    Note over CD: Write updated courses to file
    Note over ED: Write updated enrollments to file
    Note over SH: Refresh display
```

This diagram shows how the `EnrollmentDatabase` coordinates the change across both the enrollment data and the course data, requiring it to interact with the `CourseDatabase`.

## How the Application Starts and Uses Databases

Now let's tie it all back to the very beginning of the application, the `main` method in `CourseEvaluationSystem.java` ([Chapter 1: GUI Pages (LoginPage, Home screens)](01_gui_pages__loginpage__home_screens__.md)).

When the program starts, the first thing it does (after some necessary setup for the GUI) is create instances of these database classes.

```java
// --- File: src/main/java/com/courseevaluation/main/CourseEvaluationSystem.java ---
package com.courseevaluation.main;

import com.courseevaluation.data.UserDatabase;
import com.courseevaluation.data.CourseDatabase;
import com.courseevaluation.data.EnrollmentDatabase;
import com.courseevaluation.gui.LoginPage; // Import the LoginPage class
import javax.swing.SwingUtilities;

public class CourseEvaluationSystem {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            // --- Database setup happens here! ---
            // 1. Create the CourseDatabase (it loads courses immediately)
            CourseDatabase courseDatabase = new CourseDatabase();

            // 2. Create the UserDatabase (it loads users immediately)
            UserDatabase userDatabase = new UserDatabase();

            // 3. Create the EnrollmentDatabase (it needs CourseDatabase)
            //    (it loads enrollments immediately)
            EnrollmentDatabase enrollmentDatabase = new EnrollmentDatabase(courseDatabase);
            // --- Database setup complete ---

            // Create and show the LoginPage, passing the databases to it
            LoginPage loginPage = new LoginPage(userDatabase, courseDatabase, enrollmentDatabase);
            loginPage.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);
            loginPage.setSize(600, 400);
            loginPage.setLocationRelativeTo(null);
            loginPage.setVisible(true);
        });
    }
}
```

This snippet is crucial. It shows that the `main` method is responsible for:
1.  Creating a `CourseDatabase` object. This object automatically loads courses from `courses.csv`.
2.  Creating a `UserDatabase` object. This object automatically loads users from `users.csv`.
3.  Creating an `EnrollmentDatabase` object, *giving it* the `courseDatabase` object it just created. This object then automatically loads enrollments from `enrollments.csv`.
4.  Once these database objects are ready (holding all the data in memory), they are passed to the `LoginPage`.

From the `LoginPage`, the database objects are then passed along to the different `Home` screens when a user logs in ([Chapter 1: GUI Pages (LoginPage, Home screens)](01_gui_pages__loginpage__home_screens__.md)). This ensures that any part of the application that needs to access or modify data has a reference to the correct database object.

## Summary of Database Responsibilities

| Database Class      | Manages Data Type | Data File         | Key Responsibilities                                       | Depends On        |
| :------------------ | :---------------- | :---------------- | :--------------------------------------------------------- | :---------------- |
| `UserDatabase`      | `User` objects    | `data/users.csv`  | Load users, Save users, Find user by username, List all users | -                 |
| `CourseDatabase`    | `Course` objects  | `data/courses.csv`| Load courses, Save courses, Find course by code, List all courses | -                 |
| `EnrollmentDatabase`| `Enrollment` objects|`data/enrollments.csv`|Load enrollments, Save enrollments, List enrollments by student/course, Add/Remove enrollment | `CourseDatabase`  |

## Conclusion

In this final core concept chapter, we explored the **Database Classes:** `UserDatabase`, `CourseDatabase`, and `EnrollmentDatabase`. We learned that these classes act as the persistent storage managers for our application's data, handling the vital tasks of loading information from CSV files when the program starts and saving changes back to those files. We saw how each class specializes in managing a specific type of data (`User`, `Course`, `Enrollment`) and how they interact with each other (especially `EnrollmentDatabase` relying on `CourseDatabase`). Finally, we understood how the application's `main` method creates these database instances and makes them available to the rest of the system.

You now have a foundational understanding of the key components and how they interact in the `TimeTableMaker-BITS` project!

---

<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/data/courses.csv), [[2]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/data/enrollments.csv), [[3]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/data/users.csv), [[4]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/data/CourseDatabase.java), [[5]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/data/EnrollmentDatabase.java), [[6]](https://github.com/Shashwat1729/TimeTableMaker-BITS/blob/0666a980a14698de4768834da851d3268c32f2fb/src/main/java/com/courseevaluation/data/UserDatabase.java)</sup></sub>




OOPS - Course Management System | [Date Range]

Developed course management system using Java Swing with role-based authentication for multiple user types

Implemented intelligent timetable generation with conflict detection and automated scheduling algorithms

Built scalable MVC architecture with CSV-based data persistence and object-oriented design patterns